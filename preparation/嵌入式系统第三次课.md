

yocto:很多脚本，源代码编译
嵌入式发行版
虽然每次培训都会提到，但几乎没有人用


内核和文件系统是相对独立的两个部分

### 内核与文件系统
\boot 内核分区
启动管理器GRUB 跳转到内核执行 挂载文件系统 执行文件系统应用
系统启动以后再也不会访问内核，只在启动时访问
文件系统可以保存在内核里：可以保持文件系统不变；PC只有内核启动器，内核挂载到PC上

NFS：嵌入式开发常用NFS文件系统
有很多方便的地方

#### 网络文件系统

可以看到远程机器上相应项目下的内容
sitsang

命令都是以文件的形式存在Linux内
busyBox:对Linux常用命令做了简化以适应嵌入式
600k实现常用需求
小型C库
图形系统：qte，tinyX

#### busybox建立文件系统的过程
增加需要的动态链接库，如C库
相对来说有点复杂

#### 其他建立文件系统的方法
BuildRoot
工具链：编译工具链的时间比较长
没有特殊要求
包含C编译器，等三个部分
与发行版不一样，这个配置出来的东西完全按照自己的需要来自定义
好处：生成得到的文件系统可以直接使用

Yocto、OpenEmbedded(比较复杂)

#### 嵌入式Linux常用文件系统
RAM文件系统——好处：文件系统非常确定，只要复位就能复原
ROM文件系统——确定不变，有些代码可以在ROM里直接执行
JFFS2——flash——按块擦除（哪怕只改一个字节也要擦除一块，写入效率比较低，擦除次数有限，十万到一百万次；有些地方更新非常频繁，很容易超过上限——对应功能：平衡写入；后来的flash硬件自带平衡写入的逻辑，PC上的要求降低）
YAFFS——flash

#### Linux操作系统启动流程
Boot loader:加载内核，把内核放到文件系统
内核的启动地址确定，位置相关，在确定的位置编译
第一个执行的程序：\bin\init程序
第一个启动的进程：systemd（取代init？），要求非常稳定
Bootstrap:自举，自己把自己启动起来(C编译器是C语言写的，自举过程，需要有非C的编译器开始)

#### Boot loader基本功能
内核参数init
忘记密码时可以修改init参数，直接进入Bash，修改密码

如果能接触到硬件，安全性没有意义，除非全盘加密

#### 常用内核参数
root：指定文件系统位置（/dev/nfs）
rootfstype：文件系统类型
init：内核启动完成将执行的额第一个进程
console：显示内核信息的终端，多数时关闭，因为来不及看（/dev/ttyS0，串口，可以在其他机器上看到系统启动消息，查询出错信息；很多嵌入式没有显示器，只能通过串口或者网络）
	虚拟终端（virtual terminal）
mem：内存总量
ro/rw：根文件系统是只读还是可写
	以前以只读方式开始
documentation/kernel-parameters.txt

* 网络文件系统内核参数举例 
静态地址
dhcp
最后是波特率

#### Kernel Panic
挂载不了文件系统
打不开console，无法交互，处于挂起状态

#### Init
inittab脚本
initrd：挂载不到文件系统时用ram disk
qemu启动虚拟的系统
内核把很多驱动放在外面，按照你的需求把一部分驱动放到ram disk里

要掌握启动的情况
按照需求设置启动



作业2：熟悉qemu
建立文件系统
用qemu启动自己完成的文件系统(buildroot)
后续在这个文件系统里写图形界面的应用（小游戏）和驱动的程序
写成报告提交


### Linux内核

编译时指定位置，避免改动原内核文件
内核参数很多
重要的内容：驱动，文件系统（保证内核支持）——这样就可以启动了
有一些需求不满足时可以重新编译
make menuconfig(文本界面)
make xconfig(第一次会比较慢，图形界面)
localmodconfig
发行版编译内核会编译很多用不到的东西


熟悉git管理
内核主要内容是驱动


gcc完整命令：architecture-架构-平台-二进制-gcc
x86_64-PC-linux-...-gcc
最早是三元组:arm-linux-gcc
交叉编译：在一个体系结构下编译另一个体系结构下的代码
gcccc^C ?